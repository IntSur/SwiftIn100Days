# **SwiftUI in 100 Days**

## Day1：变量、常量、字符串、数字

- 给变量/常量起名要使用驼峰法
- 开发过程中尽量用let创建字符串、常量等，var会不经意间被修改。
- 字符串的长度不限
- 多行字符串需要使用三个双引号"""...."""
- 因为计算机架构是2进制的，所以算0.1+0.2不是等于0.3，而是3.0000000004。这是不可避免的。

## Day2：布尔值、字符串插值、CheckPoint1

- 字符串之间用+拼接时，+两边的类型必须相等

## Day3：数组、字典、集合、枚举

- 不能将不同类型的数据放进同一个数组内
- 常量数组sorted不会改变原数组，反而会生成下面一行的新数组。

![截屏2024-06-26 22.14.23](/Users/fan/Desktop/SwiftUIIn100Days/note/SwiftUI in 100 Days.assets/截屏2024-06-26 22.14.23.png)

- 常量数组reversed不会改变原数组，swift会记住原来的顺序，并生成一个倒序的新collection。![截屏2024-06-26 22.13.43](/Users/fan/Desktop/SwiftUIIn100Days/note/SwiftUI in 100 Days.assets/截屏2024-06-26 22.13.43.png)

- 集合（set）和数组的区别：1.无序的 2.无重复元素
- 所以集合不是append 而是用insert
- 数组中找值是按照序号一个个找下去的，非常慢。而集合里找值非常快。
- 枚举既能提高写代码的效率，也能提高swift的编译效率

## Day4：类型注释、CheckPoint2

- 寻找到适合自己的声明方式

## Day5：If、switch、三元运算符

- 寻找到适合自己的声明方式
- swift的switch语句不像c那样（即使匹配到对应的case也会跑下去）swift只会跑最终匹配到的case
- 如果希望swift执行下面没匹配到的case，就用fallthrough
- swiftUI中如果频繁使用if else，代码就会一团糟，使用三元运算符就能很好地解决这个问题
- print()里不能使用if else进行选择性打印，但用三元运算符就可以

## Day6：循环、CheckPoint3

- checkpoint3中的逻辑写起来简单 但是重在优化 需要设计出足够优化的代码逻辑

## Day7：函数、参数、返回值

- 函数如果只有一行return语句，可以直接省略return关键字
- 元组和字典的区别：字典是不确定的，需要有个default值。元祖不需要，并且可以同时容纳多个值。更像是json键值对。
- 函数名称相同，但函数参数不同，那依旧是不同的函数。类似于重载。
- 函数参数可以起两个名字，一个给外部调用时使用，一个给内部使用。

## Day8：默认值、throw截取错误、CheckPoint4

- 函数参数能给默认值
- 函数能报错抓错：do{}catch{}

## Day9：闭包、传递函数到函数、CheckPoint5

- 将一个函数复制给另一个函数时，不能加（）
- 简写闭包步骤：
  1. 因为swift已经知道sorted by：会传入两个数组对应的数据类型并丢出一个bool，所以(a: String, b: String) -> Bool in...可以简写成a, b in...
  2. 当调用sorted等函数时，可以用尾随闭包法：删掉(by：...)
  3. swift其实并不关心变量名叫什么，只关心数据类型是什么，有几个，所以变量可以写成$0、$1，同时去掉in关键词。
- 一般三种情况不考虑使用$0 $1的变量简写形式：
  1. 参数在两个以上 $0 $1 $2 $3
  2. 参数使用不止一次
  3. 闭包函数主体很长
- swift中常用isMultiple(of: Int)来判断是不是一个数的倍数或者是否是奇偶数
- for item in result {...} 通常用来循环打印数组 

## Day10：结构体、计算属性、属性观察器

- 在创建结构体实体时，Employee(name: "intSur", vacationRemaining: 3) = Employee.init(name: "intSur", vacationRemaining: 3),这个init类似于c++的类的构造函数，一般来说不用加init就可以，这是一个语法糖。
- struct一般分为两种属性：
  1. 存储属性
  2. 计算属性
- 结构体的init：自定义初始化属性，类似于c++的类的构造函数

## Day11：访问权限、静态属性和方法、CheckPoint6

- 给结构体的属性方法设置访问权限：

  1. private：外部不能使用结构体内的东西
  2. fileprivate：外部不能使用文件内的东西
  3. public：所有人都能用
  4. private(set)：外部能读取结构体内的东西，但不能写  

- 结构体static：给结构体属性、方法加上static前缀关键词，那该属性、方法就成为静态可共享的成员，该结构体的所有实体都能用到它。同时也不用必须先创建实体，才能再访问到成员。所以不用mutating关键字，结构体内的static属性就能被修改。

- static成员无法访问非static成员，非static成员可以访问static成员![截屏2024-07-14 15.55.01](/Users/fan/Desktop/SwiftUIIn100Days/note/SwiftUI in 100 Days.assets/截屏2024-07-14 15.55.01.png)

  ![截屏2024-07-14 15.54.11](/Users/fan/Desktop/SwiftUIIn100Days/note/SwiftUI in 100 Days.assets/截屏2024-07-14 15.54.11.png)

- 结构体self和Self的区别：self一般用于调用结构体成员的数值，Self一般用于调用结构体成员的数据类型

## Day12：类、继承、CheckPoint7

- 类和结构体有五个区别：

  1. 类可以继承，有子类父类。结构体就不行。
  2. 类不会自动初始化。
  3. 如果复制了一个类的实体，所有复制出来的数据都共享一份资源。
  4. 当所有类的复制实体被销毁时，类允许通过初始化器，重新初始化。
  5. 常量类实体的变量成员可以被改变。

- override：只有在子类和父类方法名、参数返回值类型名称都完全相同的情况下重载才生效。

- final：加在子类名前，意思是该子类不会有子类继承它。

- Deinitializer：析构器

  1. 析构器不需要用func关键字来声明
  2. 析构器没有参数和返回值
  3. 析构器在类的最后一个实体被销毁时自动启用
  4. 我们从不直接调用析构器
  5. 结构体没有析构

- 有四种情况：类定实体定，类定实体不定，类不定实体定，类不定实体不定。

  其实就是指针常量和常量指针的概念。所以class的特性是用指针去控制一块内存里的数据，而struct是直接控制一块内存里的数据。
  
- assertionFailure( )（断言）：当代码执行到断言，程序就会丢出错误，并终止执行。只在调试模式下生效，发布模式下这些断言会被移除。

## Day13：协议、拓展、CheckPoint8

- protocol：协议。类似于基类的概念，但与基类不同的是，**协议的子结构体必须包含协议里的所有成员，而子类不用**。
- 协议作为参数传入函数，作用：可以让协议派生出的子结构体们无缝使用该函数。
- 协议的属性必须指明{ get } { get set }
- 一个结构体可以同时继承多个协议
- Opaque return types：不透明返回类型。因为有了协议，所以多种自定义的结构体之间具有共性，当函数返回值需要返回这些自定义结构体类型时，就可以用不透明返回类型进行模糊地返回一些类型，这样比较有灵活性。
- 用extentions拓展的好处：
  1. 代码完整度：在结构体后面点一下，就能调用拓展的方法。
  2. 代码整洁性：如果不用拓展，那全局函数就会堆得到处都是。  
  3. 内部访问权限：因为是直接加在原数据结构里的，所以可以直接调用结构体里的数据。可以写出类似于sort和sorted这类可改动原字符串，不改动原字符串的方法。
- 拓展中不能新增存储属性，但可以新增计算属性。
- 拓展能实现：即拥有完全自定义的初始化器，又能使用swift自带的聪明的初始化器。
- 拓展需要放在代码顶部
- set、array、dictionary在swift中都属于一个名为“Collection”的协议
- 拓展+协议能实现：让自定义结构体的方法也能和类方法一样，有默认值，也能重写方法。
