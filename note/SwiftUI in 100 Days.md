# **SwiftUI in 100 Days**

## Day1

- 给变量/常量起名要使用驼峰法
- 开发过程中尽量用let创建字符串、常量等，var会不经意间被修改。
- 字符串的长度不限
- 多行字符串需要使用三个双引号"""...."""
- 因为计算机架构是2进制的，所以算0.1+0.2不是等于0.3，而是3.0000000004。这是不可避免的。

## Day2

- 字符串之间用+拼接时，+两边的类型必须相等

## Day3

- 不能将不同类型的数据放进同一个数组内
- 常量数组sorted不会改变原数组，反而会生成下面一行的新数组。

![截屏2024-06-26 22.14.23](/Users/fan/Desktop/SwiftUIIn100Days/note/SwiftUI in 100 Days.assets/截屏2024-06-26 22.14.23.png)

- 常量数组reversed不会改变原数组，swift会记住原来的顺序，并生成一个倒序的新collection。![截屏2024-06-26 22.13.43](/Users/fan/Desktop/SwiftUIIn100Days/note/SwiftUI in 100 Days.assets/截屏2024-06-26 22.13.43.png)

- 集合（set）和数组的区别：1.无序的 2.无重复元素
- 所以集合不是append 而是用insert
- 数组中找值是按照序号一个个找下去的，非常慢。而集合里找值非常快。
- 枚举既能提高写代码的效率，也能提高swift的编译效率

## Day4

- 寻找到适合自己的声明方式

## Day5

- 寻找到适合自己的声明方式
- swift的switch语句不像c那样（即使匹配到对应的case也会跑下去）swift只会跑最终匹配到的case
- 如果希望swift执行下面没匹配到的case，就用fallthrough
- swiftUI中如果频繁使用if else，代码就会一团糟，使用三元运算符就能很好地解决这个问题
- print()里不能使用if else进行选择性打印，但用三元运算符就可以

## Day6

- checkpoint3中的逻辑写起来简单 但是重在优化 需要设计出足够优化的代码逻辑

## Day7

- 函数如果只有一行return语句，可以直接省略return关键字
- 元组和字典的区别：字典是不确定的，需要有个default值。元祖不需要，并且可以同时容纳多个值。更像是json键值对。
- 函数名称相同，但函数参数不同，那依旧是不同的函数。类似于重载。
- 函数参数可以起两个名字，一个给外部调用时使用，一个给内部使用。

## Day8

- 函数参数能给默认值
- 函数能报错抓错：do{}catch{}

## Day9

- 将一个函数复制给另一个函数时，不能加（）
- 简写闭包步骤：
  1. 因为swift已经知道sorted by：会传入两个数组对应的数据类型并丢出一个bool，所以(a: String, b: String) -> Bool in...可以简写成a, b in...
  2. 当调用sorted等函数时，可以用尾随闭包法：删掉(by：...)
  3. swift其实并不关心变量名叫什么，只关心数据类型是什么，有几个，所以变量可以写成$0、$1，同时去掉in关键词。
- 一般三种情况不考虑使用$0 $1的变量简写形式：
  1. 参数在两个以上 $0 $1 $2 $3
  2. 参数使用不止一次
  3. 闭包函数主体很长
- swift中常用isMultiple(of: Int)来判断是不是一个数的倍数或者是否是奇偶数
- for item in result {...} 通常用来循环打印数组 

## Day10

- 在创建结构体实体时，Employee(name: "intSur", vacationRemaining: 3) = Employee.init(name: "intSur", vacationRemaining: 3),这个init类似于c++的类的构造函数，一般来说不用加init就可以，这是一个语法糖。
- struct一般分为两种属性：
  1. 存储属性
  2. 计算属性
- 结构体的init：自定义初始化属性，类似于c++的类的构造函数

## Day11

- 给结构体的属性方法设置访问权限：

  1. private：外部不能使用结构体内的东西
  2. fileprivate：外部不能使用文件内的东西
  3. public：所有人都能用
  4. private(set)：外部能读取结构体内的东西，但不能写  

- 结构体static：给结构体属性、方法加上static前缀关键词，那该属性、方法就成为静态可共享的成员，该结构体的所有实体都能用到它。同时也不用必须先创建实体，才能再访问到成员。所以不用mutating关键字，结构体内的static属性就能被修改。

- static成员无法访问非static成员，非static成员可以访问static成员![截屏2024-07-14 15.55.01](/Users/fan/Desktop/SwiftUIIn100Days/note/SwiftUI in 100 Days.assets/截屏2024-07-14 15.55.01.png)

  ![截屏2024-07-14 15.54.11](/Users/fan/Desktop/SwiftUIIn100Days/note/SwiftUI in 100 Days.assets/截屏2024-07-14 15.54.11.png)

- 结构体self和Self的区别：self一般用于调用结构体成员的数值，Self一般用于调用结构体成员的数据类型

## Day12

- 类和结构体有五个区别：

  1. 类可以继承，有子类父类。结构体就不行。
  2. 类不会自动初始化。
  3. 如果复制了一个类的实体，所有复制出来的数据都共享一份资源。
  4. 当所有类的复制实体被销毁时，类允许通过初始化器，重新初始化。
  5. 常量类实体的变量成员可以被改变。

- override：只有在子类和父类方法名、参数返回值类型名称都完全相同的情况下重载才生效。

- final：加在子类名前，意思是该子类不会有子类继承它。

- Deinitializer：析构器

  1. 析构器不需要用func关键字来声明
  2. 析构器没有参数和返回值
  3. 析构器在类的最后一个实体被销毁时自动启用
  4. 我们从不直接调用析构器
  5. 结构体没有析构

- 有四种情况：类定实体定，类定实体不定，类不定实体定，类不定实体不定。

  其实就是指针常量和常量指针的概念。所以class的特性是用指针去控制一块内存里的数据，而struct是直接控制一块内存里的数据。
